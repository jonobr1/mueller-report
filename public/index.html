<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>The Mueller Report</title>
    <link rel="stylesheet" type="text/css" href="./styles/main.css">
  </head>
  <body>
    <div class="scripts">
      <script src="./third-party/mpe.js"></script>
      <script src="./third-party/three.js"></script>
      <script src="./third-party/two.js"></script>
      <script src="./src/page-reader.js"></script>
      <script src="./src/controller.js"></script>
      <script src="./src/sequencer.js"></script>
      <script src="./src/fonts.js"></script>
      <script>

        var _ = Two.Utils;

        var dimensions = 100;
        var data, palette = {
          isPositive: false,
          background: new THREE.Color(0x000000),
          foreground: new THREE.Color(0xffffff),
          drag: 0.1
        };

        var fonts = new Fonts([
          {
            value: 'Knockout HTF66-FullFlyweight',
            url: './assets/fonts/Knockout-26.otf'
          },
          {
            value: 'Knockout HTF67-FullBantamweight',
            url: './assets/fonts/Knockout-27.otf'
          },
          {
            value: 'Knockout HTF68-FullFeatherweight',
            url: './assets/fonts/Knockout-48.otf'
          },
          {
            value: 'Knockout HTF69-FullLiteweight',
            url: './assets/fonts/Knockout-49.otf'
          },
          {
            value: 'Knockout HTF70-FullWelterweight',
            url: './assets/fonts/Knockout-70.otf'
          },
          {
            value: 'Knockout HTF71-FullMiddleweight',
            url: './assets/fonts/Knockout-71.otf'
          },
          {
            value: 'Knockout HTF72-FullCruiserweight',
            url: './assets/fonts/Knockout-72.otf'
          },
          {
            value: 'Knockout HTF73-FullHeviweight',
            url: './assets/fonts/Knockout-93.otf'
          },
          {
            value: 'Knockout HTF74-FullSumo',
            url: './assets/fonts/Knockout-94.otf'
          }
        ]);

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45);

        camera.userData.fov = 45;

        renderer.setPixelRatio(2);
        Two.Text.Ratio = 1;

        var two = new Two({
          type: Two.Types.canvas,
          width: 512,
          height: 512,
          ratio: 2
        });

        var text = two.makeText('', 0, 0, {
          fill: 'white',
          stroke: 'transparent',
          family: '"Knockout HTF26-JuniorFlyweight", sans-serif'
        });

        var plane = new THREE.Mesh(
          new THREE.PlaneBufferGeometry(dimensions, dimensions, 128, 128),
          new THREE.ShaderMaterial({

            uniforms: {
              dimensions: { type: 'f', value: dimensions },
              time: { type: 'f', value: 0 },
              speed: { type: 'f', value: 1 },
              turbulence: { type: 'v2', destination: new THREE.Vector2(), value: new THREE.Vector2( 0, 0 ) },
              color: { type: 'c', value: palette.foreground },
              map: { type: 't', value: new THREE.Texture(two.renderer.domElement) },
              opacity: { type: 'f', value: 1 }
            },

            vertexShader: [

              'const float PI =' + Math.PI + ';',
              'uniform float dimensions;',
              'uniform float speed;',
              'uniform float time;',
              'uniform vec2 turbulence;',

              'varying vec2 vUv;',

              'vec2 hash( vec2 x ) {',
                'const vec2 k = vec2( 0.3183099, 0.3678794 );',
                'x = x * k + k.yx;',
                'return 2.0 * fract( 16.0 * k * fract( x.x * x.y * ( x.x + x.y ) ) ) - 1.0;',
              '}',

              'float noise( in vec2 p ) {',
                'vec2 i = floor( p );',
                'vec2 f = fract( p );',

                'vec2 u = f * f * ( 3.0 - 2.0 * f );',

                'return mix( mix( dot( hash( i + vec2( 0.0, 0.0 ) ), f - vec2( 0.0, 0.0 ) ),',
                                 'dot( hash( i + vec2( 1.0, 0.0 ) ), f - vec2( 1.0, 0.0 ) ), u.x ),',
                            'mix( dot( hash( i + vec2( 0.0, 1.0 ) ), f - vec2( 0.0, 1.0 ) ),',
                                 'dot( hash( i + vec2( 1.0, 1.0 ) ), f - vec2( 1.0, 1.0 ) ), u.x ), u.y );',
              '}',

              'void main() {',

                'vUv = uv;',

                'vec2 n = 2.0 * ( vec2( uv ) - 0.5 );',
                'float dist = distance( n, turbulence );',
                'n += turbulence * max( 1.0 - dist, 0.0 );',
                'vec3 pos = vec3( dimensions * n * 0.5, position.z );',

                'gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );',

              '}'

            ].join('\n'),

            fragmentShader: [

              'uniform vec3 color;',
              'uniform sampler2D map;',
              'uniform float opacity;',

              'varying vec2 vUv;',

              'void main() {',
                'vec4 texel = texture2D( map, vUv );',
                'gl_FragColor = vec4( color, texel.a * opacity );',
              '}'

            ].join('\n'),

            // wireframe: true,
            transparent: true

          })
        );

        plane.userData.active = false;

        var controller = new Controller();

        var reader = new PageReader('./assets/mueller-report.json');
        reader.bind('load', setup);

        var sequencer = new Sequencer();

        function setup() {

          camera.position.z = dimensions;

          scene.add(plane);

          renderer.setClearColor(palette.background);
          document.body.appendChild(renderer.domElement);

          two.scene.position.set(two.width / 2, two.height / 2);

          nextPage();

          controller.bind('down', onControllerDown)
            .bind('update', onControllerUpdate)
            .bind('up', onControllerUp)
            .bind('blur', onControllerBlur);

          sequencer.bind('down', onSequenceDown)
            .bind('up', onSequenceUp)
            .bind('blur', onSequenceBlur);

          window.addEventListener('resize', resize, false);
          resize();
          renderer.setAnimationLoop(update);

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix()

        }

        function update(elapsed) {

          sequencer.update();

          plane.material.uniforms.time.value = elapsed;

          if (camera.fov !== camera.userData.fov) {
            camera.fov += (camera.userData.fov - camera.fov) * 0.33;
            camera.updateProjectionMatrix();
          }

          var clearColorNeedsUpdate = false;

          if (palette.background.r > 0.001) {
            palette.background.r -= palette.background.r * palette.drag;
            clearColorNeedsUpdate = true;
          } else if (palette.background.r !== 0) {
            palette.background.r = 0;
            clearColorNeedsUpdate = true;
          }

          if (palette.background.g > 0.001) {
            palette.background.g -= palette.background.g * palette.drag;
            clearColorNeedsUpdate = true;
          } else if (palette.background.g !== 0) {
            palette.background.g = 0;
            clearColorNeedsUpdate = true;
          }

          if (palette.background.b > 0.001) {
            palette.background.b -= palette.background.b * palette.drag;
            clearColorNeedsUpdate = true;
          } else if (palette.background.b !== 0) {
            palette.background.b = 0;
            clearColorNeedsUpdate = true;
          }

          if (clearColorNeedsUpdate) {
            renderer.setClearColor(palette.background);
          }

          if (!plane.userData.active) {
            plane.material.uniforms.opacity.value
              -= plane.material.uniforms.opacity.value * 0.1;
          }

          var turbulence = plane.material.uniforms.turbulence;
          turbulence.value.x += (turbulence.destination.x - turbulence.value.x) * 0.33;
          turbulence.value.y += (turbulence.destination.y - turbulence.value.y) * 0.33;

          var cp = controller.pressure;
          var pressure = Math.pow(cp, 5);

          if (pressure > 0) {
            var x = pressure * (Math.random() - 0.5) / 2;
            var y = pressure * (Math.random() - 0.5) / 2;
            plane.position.set(x, y, 0);
          } else if (plane.position.x !== 0
            || plane.position.y !== 0 || plane.position.z !== 0) {
            plane.position.set(0, 0, 0);
          }

          // updateText({ noteNumber: Controller.MinNote });

          renderer.render(scene, camera);

        }

        function onControllerDown(e) {

          var turbulence = plane.material.uniforms.turbulence.destination;

          if (sequencer.getRecording() && sequencer.getCurrent()) {
            sequencer.getCurrent().add('down', e);
          }

          switch (getIndexFromNote(e.noteNumber)) {

            // "Black Keys"
            case 1:
              if (e.timbre >= 0.5) {
                sequencer.setRecording(true);
              }
              break;
            case 3:
              if (e.timbre >= 0.5) {
                sequencer.clear();
              }
              break;
            case 6:
            case 8:
            case 10:
            case 13:
            case 15:
            case 18:
            case 20:
              break;
            case 22:
              if (e.timbre >= 0.5) {
                turbulence.enabled = !turbulence.enabled;
              }
              break;
            default:
              // "White Keys"
              updateText(e);
          }

        }

        function onSequenceDown(e) {

          switch (getIndexFromNote(e.noteNumber)) {

            // "Black Keys"
            case 1:
            case 3:
            case 6:
            case 8:
            case 10:
            case 13:
            case 15:
            case 18:
            case 20:
              break;
            case 22:
              break;
            default:
              // "White Keys"
              updateText(e);
          }

        }

        function onControllerUpdate(e) {

          var turbulence = plane.material.uniforms.turbulence.destination;
          var x, y;

          switch (getIndexFromNote(e.noteNumber)) {
            case 1:
            case 3:
            case 6:
            case 8:
            case 10:
            case 13:
            case 15:
              break;
            case 18:
              if (e.timbre > 0.5) {
                var zoom = (e.timbre - 0.5) / (1 - 0.5);
                camera.userData.fov = (1 - zoom) * 140 + 15;
              }
              break;
            case 20:
              if (turbulence.enabled) {
                turbulence.x = 2 * (Math.random() - 0.5) * e.pressure;
                turbulence.y = 2 * (Math.random() - 0.5) * e.pressure;
              }
              break;
            case 22:
              break;
            default:
              x = e.pitchBend;
              y = 2 * (e.timbre - 0.5);
              if (turbulence.enabled) {
                turbulence.x = Math.pow(x, 3);
                turbulence.y = Math.pow(y, 3);
              } else {
                turbulence.x = 0;
                turbulence.y = 0;
              }
          }

        }

        function onControllerUp(e) {

          switch (getIndexFromNote(e.noteNumber)) {
            case 1:
              if (e.timbre >= 0.5) {
                sequencer.setRecording(false);
              }
              break;
            default:
              if (sequencer.getRecording() && sequencer.getCurrent()) {
                sequencer.getCurrent().add('up', e);
              }
          }

        }

        function onSequenceUp(e) {

          switch (getIndexFromNote(e.noteNumber)) {
            case 22:
              break;
          }

        }

        function onControllerBlur() {

          if (sequencer.getRecording() && sequencer.getCurrent()) {
            sequencer.getCurrent().add('blur');
          }

          plane.userData.active = false;

        }

        function onSequenceBlur() {

          plane.userData.active = false;

        }

        function updateText(e) {

          var index = data.index;
          var word = data[index];

          if (_.isObject(word)) {
            text.value = word.value.toUpperCase();
            palette.drag = 1 / word.length;
          } else {
            text.value = data[index].toUpperCase();
          }
          text.scale = 1;

          if (/redacted/i.test(text.value)) {
            palette.background.r = 1;
          }

          var rect = text.getBoundingClientRect(true);
          text.scale = Math.min(two.height / rect.height, two.width / rect.width, 10);

          var pct = getPctFromNote(e.noteNumber);
          var index = Math.floor(fonts.families.length * pct);
          var font = fonts.families[index];
          if (!font) {
            console.warn('Font does not exist for index', index, 'perhaps the octave key was pressed?');
            return;
          }
          text.family = fonts.families[index].family;

          two.update();

          plane.material.uniforms.map.value.needsUpdate = true;
          plane.material.uniforms.opacity.value = 1;
          plane.userData.active = true;

          data.index++;
          if (data.index >= data.length) {
            nextPage();
          }

        }

        function nextPage() {

          data = reader.next();
          data.index = 0;

        }

        function getPctFromNote(note) {
          return (note - Controller.MinNote)
            / ((Controller.MaxNote + 1) - Controller.MinNote);
        }

        function getIndexFromNote(note) {
          return note - Controller.MinNote;
        }

      </script>
    </div>
  </body>
</html>
